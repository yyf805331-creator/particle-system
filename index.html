<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL PARTICLE SYSTEM - 2026</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <style>
        :root {
            --neon-cyan: #00f3ff;
            --neon-pink: #ff00ff;
            --bg-dark: #050505;
        }

        body, html {
            margin: 0; padding: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Segoe UI', 'Courier New', monospace;
        }

        /* 赛博朋克故障标题 */
        .header {
            position: absolute;
            top: 40px; left: 40px;
            z-index: 100;
            pointer-events: none;
        }

        .glitch {
            font-size: 2.5rem;
            font-weight: bold;
            text-transform: uppercase;
            color: white;
            position: relative;
            text-shadow: 0.05em 0 0 var(--neon-cyan), -0.05em -0.025em 0 var(--neon-pink);
            animation: glitch 1s infinite;
        }

        @keyframes glitch {
            0% { text-shadow: 0.05em 0 0 var(--neon-cyan), -0.05em -0.025em 0 var(--neon-pink); }
            14% { text-shadow: 0.05em 0 0 var(--neon-cyan), -0.05em -0.025em 0 var(--neon-pink); }
            15% { text-shadow: -0.05em -0.025em 0 var(--neon-cyan), 0.025em 0.025em 0 var(--neon-pink); }
            49% { text-shadow: -0.05em -0.025em 0 var(--neon-cyan), 0.025em 0.025em 0 var(--neon-pink); }
            50% { text-shadow: 0.025em 0.05em 0 var(--neon-cyan), 0.05em 0 0 var(--neon-pink); }
            99% { text-shadow: 0.025em 0.05em 0 var(--neon-cyan), 0.05em 0 0 var(--neon-pink); }
            100% { text-shadow: -0.025em 0 0 var(--neon-cyan), -0.025em -0.025em 0 var(--neon-pink); }
        }

        /* HUD 界面 */
        #hud {
            position: absolute;
            bottom: 40px; left: 40px;
            color: var(--neon-cyan);
            font-size: 12px;
            line-height: 1.5;
            border-left: 2px solid var(--neon-cyan);
            padding-left: 15px;
            text-transform: uppercase;
            pointer-events: none;
        }

        #hint {
            position: absolute;
            bottom: 40px; right: 40px;
            color: white;
            opacity: 0.5;
            font-size: 12px;
        }
    </style>
</head>
<body>

    <div class="header">
        <div class="glitch" data-text="NEURAL_CORE">NEURAL_CORE</div>
        <div style="color: var(--neon-cyan); letter-spacing: 5px; font-size: 12px;">SYSTEM STATUS: ONLINE</div>
    </div>

    <div id="hud">
        FPS: <span id="fps">60</span><br>
        PARTICLES: 100,000<br>
        MORPH_STATE: <span id="state">SPHERE</span><br>
        Z-COORD: <span id="z-coord">0.00</span>
    </div>

    <div id="hint">CLICK TO TRANSFIGURE / MOVE MOUSE TO ROTATE</div>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float u_time;
        uniform float u_transition;
        uniform float u_shape; // 0: Sphere, 1: Torus, 2: Noise, 3: Cube
        
        attribute vec3 positionSphere;
        attribute vec3 positionTorus;
        attribute vec3 positionNoise;
        attribute vec3 positionCube;
        attribute vec3 color;

        varying vec3 vColor;
        varying float vDistance;

        // Simplex 3D Noise 简易实现
        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
        float snoise(vec3 v){ 
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 =   v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + 1.0 * C.xxx;
            vec3 x2 = x0 - i2 + 2.0 * C.xxx;
            vec3 x3 = x0 - 1. + 3. * C.xxx;
            i = mod(i, 289.0 ); 
            vec4 p = permute( permute( permute( 
                     i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 1.0/7.0;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z *ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
            vColor = color;
            
            // 基于状态的混合
            vec3 targetPos;
            if(u_shape < 0.5) {
                targetPos = mix(positionCube, positionSphere, u_transition);
            } else if(u_shape < 1.5) {
                targetPos = mix(positionSphere, positionTorus, u_transition);
            } else if(u_shape < 2.5) {
                targetPos = mix(positionTorus, positionNoise, u_transition);
            } else {
                targetPos = mix(positionNoise, positionCube, u_transition);
            }

            // 添加动态噪声扰动
            float noise = snoise(targetPos * 0.5 + u_time * 0.2);
            targetPos += noise * 0.1;

            vec4 mvPosition = modelViewMatrix * vec4(targetPos, 1.0);
            vDistance = length(mvPosition.xyz);
            
            gl_PointSize = (40.0 / vDistance) * (1.0 + noise * 0.5);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        varying float vDistance;

        void main() {
            // 制作圆形粒子
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            
            // 边缘柔化
            float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
            
            // 根据距离调整亮度
            float glow = 0.05 / (vDistance * 0.05);
            
            gl_FragColor = vec4(vColor + glow, alpha);
        }
    </script>

    <script>
        /**
         * 初始化核心引擎
         */
        let scene, camera, renderer, composer, particles, material;
        let currentShape = 0; // 0: Sphere, 1: Torus, 2: Noise, 3: Cube
        const particleCount = 100000;
        
        const shapes = ['SPHERE', 'TORUS', 'NOISE_CLOUD', 'CUBE'];

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // 几何体准备
            const geo = new THREE.BufferGeometry();
            const positions = {
                sphere: new Float32Array(particleCount * 3),
                torus: new Float32Array(particleCount * 3),
                noise: new Float32Array(particleCount * 3),
                cube: new Float32Array(particleCount * 3),
                colors: new Float32Array(particleCount * 3)
            };

            const color1 = new THREE.Color("#00f3ff"); // 霓虹青
            const color2 = new THREE.Color("#ff00ff"); // 霓虹粉

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                // 1. Sphere (球体)
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = 2.0;
                positions.sphere[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions.sphere[i3+1] = r * Math.sin(phi) * Math.sin(theta);
                positions.sphere[i3+2] = r * Math.cos(phi);

                // 2. Torus (圆环)
                const tr = 2.0; // 主半径
                const tt = 0.6; // 管道半径
                const uT = Math.random() * Math.PI * 2;
                const vT = Math.random() * Math.PI * 2;
                positions.torus[i3] = (tr + tt * Math.cos(vT)) * Math.cos(uT);
                positions.torus[i3+1] = (tr + tt * Math.cos(vT)) * Math.sin(uT);
                positions.torus[i3+2] = tt * Math.sin(vT);

                // 3. Noise Cloud (噪声云 - 随机散点)
                positions.noise[i3] = (Math.random() - 0.5) * 6;
                positions.noise[i3+1] = (Math.random() - 0.5) * 6;
                positions.noise[i3+2] = (Math.random() - 0.5) * 6;

                // 4. Cube (立方体)
                positions.cube[i3] = (Math.random() - 0.5) * 3.5;
                positions.cube[i3+1] = (Math.random() - 0.5) * 3.5;
                positions.cube[i3+2] = (Math.random() - 0.5) * 3.5;

                // 颜色混叠
                const mixedColor = color1.clone().lerp(color2, Math.random());
                positions.colors[i3] = mixedColor.r;
                positions.colors[i3+1] = mixedColor.g;
                positions.colors[i3+2] = mixedColor.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(positions.cube, 3)); // 初始位置
            geo.setAttribute('positionSphere', new THREE.BufferAttribute(positions.sphere, 3));
            geo.setAttribute('positionTorus', new THREE.BufferAttribute(positions.torus, 3));
            geo.setAttribute('positionNoise', new THREE.BufferAttribute(positions.noise, 3));
            geo.setAttribute('positionCube', new THREE.BufferAttribute(positions.cube, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(positions.colors, 3));

            // 材质
            material = new THREE.ShaderMaterial({
                uniforms: {
                    u_time: { value: 0 },
                    u_transition: { value: 0 },
                    u_shape: { value: 3 } // 初始为 Cube
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geo, material);
            scene.add(particles);

            // 后期处理 (Bloom)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            setupInteraction();
            animate();
        }

        /**
         * 交互逻辑
         */
        function setupInteraction() {
            window.addEventListener('mousedown', () => {
                const nextShape = (currentShape + 1) % 4;
                
                // GSAP 动画控制着色器 Uniform
                gsap.to(material.uniforms.u_transition, {
                    value: 1.0,
                    duration: 1.5,
                    ease: "expo.inOut",
                    onComplete: () => {
                        currentShape = nextShape;
                        material.uniforms.u_shape.value = currentShape;
                        material.uniforms.u_transition.value = 0;
                        document.getElementById('state').innerText = shapes[currentShape];
                    }
                });
            });

            // 鼠标移动旋转效果
            let mouseX = 0, mouseY = 0;
            window.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / window.innerWidth - 0.5) * 0.5;
                mouseY = (e.clientY / window.innerHeight - 0.5) * 0.5;
            });

            // 窗口缩放适配
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // 简单的每秒旋转逻辑
            gsap.ticker.add(() => {
                particles.rotation.y += (mouseX - particles.rotation.y) * 0.05;
                particles.rotation.x += (mouseY - particles.rotation.x) * 0.05;
            });
        }

        /**
         * 循环渲染
         */
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            const delta = time - lastTime;
            lastTime = time;

            material.uniforms.u_time.value = time * 0.001;
            
            // 更新 HUD
            if(Math.random() > 0.9) {
                document.getElementById('fps').innerText = Math.round(1000 / delta);
                document.getElementById('z-coord').innerText = particles.rotation.y.toFixed(2);
            }

            composer.render();
        }

        init();
    </script>
</body>
</html>